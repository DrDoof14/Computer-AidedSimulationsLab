# -*- coding: utf-8 -*-
"""lab11.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19zCjOqGim21MO7ywQqWSOB22UbepKTY4
"""

#2 class of customers with 2 priority
#when higher priority come，switch the
#2 envents of begining at the 2 arrivals
#possion lambda each loop

#1: waiting room
  # about the waiting room:
  # LP customer is potentially  dropped if there is not room in the waiting line.
  # thought：last come first dropped
#2: 2server to serve customer
#output:
#Plot of the average delay  for HP customers, LP customers, end the aggregate average delay

import random
import numpy as np
from queue import PriorityQueue
import time
from scipy import stats
import matplotlib.pyplot as plt
import math

# *****
#-- total number of arrivals, Narr
#-- total number of departures, Ndep
#-- integral of the number of client in time
#-- store the time of the last event (for computing the integral)
#-- total delay in the queue
#-- time list is arrival or departure time
#-- a list of Delay time
#--
class Measure:
    def __init__(self,Narr,Ndep,NAveraegUser,OldTimeEvent,AverageDelay,TimeList,DelayList):
        self.arr = Narr
        self.dep = Ndep
        self.ut = NAveraegUser
        self.oldT = OldTimeEvent
        self.delay = AverageDelay
        self.timelist = TimeList
        self.delayList = DelayList

# ******
# Customer
#-- time of arrival
#-- define the customer priority HP:1 LP:0
class Customer:
    def __init__(self,arrival_time,type):
        self.arrival_time = arrival_time
        self.type = 0

# *****
# Server
#--
class Server():
  def __init__(self, sid : int, status : str, customer):
      self.id = sid
      self.status = status
      self.customer = curtCustomer

#define the generator of hyper-exp number
def get_hypexp():
  p=0.99
  m1=2 + math.sqrt(2)
  m2=(99*math.sqrt(2) - 2)/(9799)
  prob = random.random()
  if prob <= p:
    expec = m1
  else:
    expec = m2
  serviceTime = random.expovariate(1/expec)
  return serviceTime

# arrival processes are Poisson with rate 2 lambda
def get_ArivalTime():

  return arivalTime

#service time generage
#-- indicator = *
#-- 0 : exponential distributed with mean=SERVICE
#-- 1 : exponentially distributed with mean=1
#-- 2 : deterministic =1
#-- 3 : hyper-exponential distribution with mean=1 standard deviation=10
def get_ServiceTime(indicator,avgServiceTime):
  if indicator == 0:
    serviceTime = random.expovariate(1.0/avgServiceTime)
  elif indicator == 1:
    serviceTime = random.expovariate(1.0/1.0)
  elif indicator == 2:
    serviceTime = 1
  elif indicator == 3:
    serviceTime = ger_hypexp()
  return serviceTime

# ******
# ARRIVAL: event function
#-- the FES, for events schedule
#-- the queue of the customer
def arrival(time, FES, queue, service_time, utilisation):
    global users

    # cumulate statistics
    data.arr += 1
    data.ut += users*(time-data.oldT)
    data.oldT = time

    # sample the time until the next arrival
    conditional_time = 1.0/(service_time/utilisation)
    inter_arrival = random.expovariate(conditional_time)

    # schedule the next arrival
    FES.put((time + inter_arrival, "arrival"))

    # update the state variable, by increasing the no. of clients by 1
    users += 1

    # create a record for the client
    type = random.randint(0,2)
    customer = Customer(time,type)

    # insert the record in the queue
    queue.append(customer)

    # if the server is idle start the service
    if users==1:
        # sample the service time
        service_time = service_time
        # schedule the departure of the client
        FES.put((time + service_time, "departure"))

# ******
def departure(time, FES, queue, service_time):
    global users

    # get the first element from the queue
    customer = queue.pop(0)
    delayT = time-customer.arrival_time
    # cumulate statistics
    data.dep += 1
    data.ut += users*(time-data.oldT)
    data.oldT = time
    data.delay += (delayT)
    data.timelist.append(time)
    data.delayList.append(delayT)
    # update the state variable, by decreasing the no. of clients by 1
    users -= 1

    # check whether there are more clients to in the queue
    if users >0:
        # sample the service time
        service_time = service_time
        # schedule the departure of the client
        FES.put((time + service_time, "departure"))

#******
#-- using the graph to calculate the critical value identifies the warm-up period

# we could add the simulation result in
def plot_TransientFigure(customerList, delayList, avgDelay, utilisation, indicator):
  scenario = ""
  if indicator ==1:
    scenario = "exponentially distributed"
  elif indicator ==2:
    scenario = "deterministic distributed"
  elif indicator ==3:
    scenario = "hyper-exponential distribution"
  #paint the time with number of users in group
  plt.plot(customerList,delayList,color ='blue')

  #paint the theorical average number of users
  plt.axhline(avgDelay, linestyle='--', color='C1', label='Avarage Simulation delay')

  plt.xlabel("time")
  plt.ylabel("delay time")
  plt.title(f"Transient Detectation with Cumulative Delay ({scenario}scenario) of {utilisation}utilisation")
  plt.legend()
  plt.grid()
  plt.show()
  plt.close()

#use a list to be the waiting room
#if the queue maximum, the customer trans to the waiting room
waitingRoom = [];









